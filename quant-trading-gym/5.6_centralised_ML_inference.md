# V5.6: Centralized ML Inference

## Problem Statement

Each `TreeAgent` independently extracts 42 features and calls `model.predict()` per tick, even when multiple agents share the same model and trade the same symbol.

**Current bottleneck** (in `tree_agent.rs:298-301`):
```rust
for symbol in &self.config.symbols {
    let features = self.extract_features(symbol, ctx);
    let probs: ClassProbabilities = self.model.predict(&features);
    // ...
}
```

With N agents, M models, and S symbols, this causes:
- N feature extractions per tick
- N model predictions per tick

**Optimal**:
- S feature extractions per tick
- M × S predictions per tick

## Current Architecture Context

### Tick Loop (runner.rs:805-919)

The simulation runs a 14-phase tick loop:

```
Phase 0:  Process news events
Phase 0b: Apply fair value drift
Phase 1:  Hook: on_tick_start
Phase 2:  Determine agents to call (T1 always, T2 conditional)
Phase 3:  Build StrategyContext (indicators computed ONCE) <-- INJECTION POINT
Phase 4:  Collect agent actions (parallel on_tick() calls)
Phase 5:  Collect orders from T1/T2 agents
Phase 5b: Generate Tier 3 background pool orders
Phase 6:  Hook: on_orders_collected
Phase 7:  Run batch auction per symbol
Phase 8:  Update Tier 3 pool accounting
Phase 9:  Hook: on_trades
Phase 10: Update market data
Phase 11: Notify agents of fills
Phase 12: Update risk tracking
Phase 13: Hook: on_tick_end
Phase 14: Finalize tick
```

**Key insight**: Phase 3 already computes `IndicatorSnapshot` once and shares it via `StrategyContext`. ML predictions should follow the same pattern.

### StrategyContext (context.rs)

```rust
pub struct StrategyContext<'a> {
    pub tick: Tick,
    pub timestamp: Timestamp,
    market: &'a dyn MarketView,
    candles: &'a HashMap<Symbol, Vec<Candle>>,
    indicators: &'a IndicatorSnapshot,  // Already centralized!
    recent_trades: &'a HashMap<Symbol, Vec<Trade>>,
    events: &'a [news::NewsEvent],
    fundamentals: &'a news::SymbolFundamentals,
}
```

### TreeAgent Feature Extraction (tree_agent.rs:121-233)

Extracts 42 features per symbol:
- Price history (25): mid price, 12 price changes, 12 log returns at lookbacks [1,2,3,4,6,8,12,16,24,32,48,64]
- Technical indicators (13): SMA(8,16), EMA(8,16), RSI(8), MACD(3), Bollinger(4), ATR(8)
- News features (4): has_active_news, sentiment, magnitude, ticks_remaining

NaN values are imputed to -1.0 to match training behavior.

### Model Sharing (main.rs)

Models are cloned per-agent via round-robin:
```rust
(0..count).map(|i| {
    Box::new(TreeAgent::new(
        AgentId(start_id + i),
        models[i % models.len()].clone(),  // ROUND-ROBIN
        agent_config.clone(),
    ))
})
```

Multiple agents may use the same model type (e.g., 97 agents each with model[0], 97 with model[1]).

## Proposed Solution

### Architecture

```
Phase 3 (StrategyContext Builder)
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│            MlPredictionCache (NEW)                       │
│  ┌─────────────────────────────────────────────────────┐│
│  │ features: HashMap<Symbol, [f64; 42]>                 ││
│  │   - Extract ONCE per symbol per tick                 ││
│  └─────────────────────────────────────────────────────┘│
│  ┌─────────────────────────────────────────────────────┐│
│  │ predictions: HashMap<(ModelName, Symbol), [f64; 3]>  ││
│  │   - Predict ONCE per (model, symbol) per tick        ││
│  └─────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────┘
    │
    ▼
StrategyContext (extended with Option<&MlPredictionCache>)
    │
    ▼
TreeAgent::on_tick() - uses cached predictions if available
```

### Implementation Steps

#### Step 1: Create MlPredictionCache

**New file**: `crates/agents/src/ml_cache.rs`

```rust
use std::collections::HashMap;
use types::{N_MARKET_FEATURES, Symbol};

pub type PredictionKey = (String, Symbol);  // (model_name, symbol)
pub type ClassProbabilities = [f64; 3];

#[derive(Debug, Clone, Default)]
pub struct MlPredictionCache {
    pub tick: u64,
    features: HashMap<Symbol, [f64; N_MARKET_FEATURES]>,
    predictions: HashMap<PredictionKey, ClassProbabilities>,
}

impl MlPredictionCache {
    pub fn new(tick: u64) -> Self { ... }
    pub fn insert_features(&mut self, symbol: Symbol, features: [f64; 42]) { ... }
    pub fn get_features(&self, symbol: &Symbol) -> Option<&[f64; 42]> { ... }
    pub fn insert_prediction(&mut self, model_name: &str, symbol: &Symbol, probs: [f64; 3]) { ... }
    pub fn get_prediction(&self, model_name: &str, symbol: &Symbol) -> Option<[f64; 3]> { ... }
}
```

#### Step 2: Create Shared Feature Extractor

**New file**: `crates/agents/src/tier1/ml/feature_extractor.rs`

Move `TreeAgent::extract_features` to a public standalone function:

```rust
pub fn extract_features(symbol: &Symbol, ctx: &StrategyContext<'_>) -> [f64; N_MARKET_FEATURES] {
    // Same logic as TreeAgent::extract_features (lines 121-233)
}
```

#### Step 3: Extend StrategyContext

**File**: `crates/agents/src/context.rs`

```rust
pub struct StrategyContext<'a> {
    // ... existing fields ...
    ml_cache: Option<&'a MlPredictionCache>,
}

impl<'a> StrategyContext<'a> {
    pub fn with_ml_cache(..., ml_cache: &'a MlPredictionCache) -> Self { ... }
    pub fn ml_cache(&self) -> Option<&MlPredictionCache> { ... }
    pub fn get_ml_prediction(&self, model_name: &str, symbol: &Symbol) -> Option<[f64; 3]> { ... }
}
```

#### Step 4: Create Model Registry

**New file**: `crates/agents/src/tier1/ml/model_registry.rs`

```rust
use std::sync::Arc;

pub struct ModelRegistry {
    models: HashMap<String, Arc<dyn MlModel>>,
}

impl ModelRegistry {
    pub fn register<M: MlModel + 'static>(&mut self, model: M) { ... }

    /// Compute all predictions for all symbols - O(M × S) instead of O(N)
    pub fn compute_all_predictions(
        &self,
        ctx: &StrategyContext<'_>,
        symbols: &[Symbol],
        cache: &mut MlPredictionCache,
    ) {
        // Extract features for all symbols (O(S))
        for symbol in symbols {
            if cache.get_features(symbol).is_none() {
                let features = extract_features(symbol, ctx);
                cache.insert_features(symbol.clone(), features);
            }
        }

        // Compute predictions for all (model, symbol) pairs (O(M × S))
        for (model_name, model) in &self.models {
            for symbol in symbols {
                if let Some(features) = cache.get_features(symbol) {
                    let probs = model.predict(features);
                    cache.insert_prediction(model_name, symbol, probs);
                }
            }
        }
    }
}
```

#### Step 5: Modify TreeAgent to Use Cache

**File**: `crates/agents/src/tier1/ml/tree_agent.rs`

```rust
fn on_tick(&mut self, ctx: &StrategyContext<'_>) -> AgentAction {
    if ctx.tick < 1000 {
        return AgentAction::none();
    }

    let mut orders: Vec<Order> = Vec::new();
    let model_name = self.model.name();

    for symbol in &self.config.symbols {
        // OPTIMIZATION: Use cached prediction if available
        let probs: ClassProbabilities = ctx
            .get_ml_prediction(model_name, symbol)
            .unwrap_or_else(|| {
                // Fallback: compute locally (backward compatibility)
                let features = extract_features(symbol, ctx);
                self.model.predict(&features)
            });

        // ... rest of decision logic unchanged (lines 303-337) ...
    }
    // ...
}
```

#### Step 6: Integrate into Simulation Runner

**File**: `crates/simulation/src/runner.rs`

In `Simulation` struct:
```rust
model_registry: Option<ModelRegistry>,
```

In `step()` Phase 3 (after line 834):
```rust
// Phase 3: Build strategy context for agents
let candles_map = self.build_candles_map();
let trades_map = self.build_trades_map();
let indicators = self.build_indicator_snapshot();

// V5.6: Build ML prediction cache if registry exists
let ml_cache = self.model_registry.as_ref().map(|registry| {
    let symbols: Vec<_> = self.config.symbols();
    let temp_ctx = StrategyContext::new(
        self.tick, self.timestamp, &self.market, &candles_map,
        &indicators, &trades_map, self.news_engine.active_events(),
        self.news_engine.fundamentals(),
    );
    let mut cache = MlPredictionCache::new(self.tick);
    registry.compute_all_predictions(&temp_ctx, &symbols, &mut cache);
    cache
});

let ctx = match &ml_cache {
    Some(cache) => StrategyContext::with_ml_cache(
        self.tick, self.timestamp, &self.market, &candles_map,
        &indicators, &trades_map, self.news_engine.active_events(),
        self.news_engine.fundamentals(), cache,
    ),
    None => StrategyContext::new(
        self.tick, self.timestamp, &self.market, &candles_map,
        &indicators, &trades_map, self.news_engine.active_events(),
        self.news_engine.fundamentals(),
    ),
};
```

Add method:
```rust
pub fn register_ml_model<M: MlModel + 'static>(&mut self, model: M) {
    self.model_registry
        .get_or_insert_with(ModelRegistry::new)
        .register(model);
}
```

#### Step 7: Register Models at Startup

**File**: `src/main.rs`

In `spawn_tree_agents`:
```rust
// Register unique models with simulation for centralized caching
for model in &decision_trees {
    sim.register_ml_model(model.clone());
}
for model in &random_forests {
    sim.register_ml_model(model.clone());
}
for model in &gradient_boosteds {
    sim.register_ml_model(model.clone());
}
```

## Files Summary

| File | Action |
|------|--------|
| `crates/agents/src/ml_cache.rs` | CREATE |
| `crates/agents/src/tier1/ml/feature_extractor.rs` | CREATE |
| `crates/agents/src/tier1/ml/model_registry.rs` | CREATE |
| `crates/agents/src/context.rs` | MODIFY - add ml_cache field |
| `crates/agents/src/tier1/ml/tree_agent.rs` | MODIFY - use cache |
| `crates/agents/src/tier1/ml/mod.rs` | MODIFY - export modules |
| `crates/agents/src/lib.rs` | MODIFY - export ml_cache |
| `crates/simulation/src/runner.rs` | MODIFY - build cache in Phase 3 |
| `src/main.rs` | MODIFY - register models |

## Performance Impact

| Metric | Before | After |
|--------|--------|-------|
| Feature extractions/tick | N agents | S symbols |
| Model predictions/tick | N agents | M × S |

**Example**: 100 agents, 3 models, 10 symbols
- Before: 100 extractions, 100 predictions
- After: 10 extractions, 30 predictions (~3x improvement)

## Backward Compatibility

- `StrategyContext::new()` sets `ml_cache: None` - existing code unchanged
- TreeAgent falls back to local computation if cache unavailable
- Non-ML agents unaffected
- Existing tests continue to work

## Verification Plan

1. Run existing tests: `cargo test -p agents`
2. Run simulation with/without model registry - verify identical trading behavior
3. Add timing instrumentation to measure prediction phase duration
4. Compare tick throughput before/after optimization
