# V6.4: PyO3 Bindings

## Overview

New crate `crates/gym-python/` providing Python bindings for `TradingEnv` via PyO3. Enables Python training code (scikit-learn, stable-baselines3) to call the Rust gym environment. Direction: Python calls Rust (training), NOT Rust calls Python (inference).

**Requires**: V6.3 complete (`TradingEnv` with step/reset/seed)

## Design Decisions

### 1. GIL Release During Rust Computation

All Rust computation runs inside `py.allow_threads()`, releasing the Python GIL. This is critical for:
- `PyVecTradingEnv`: Multiple environments step in parallel via rayon
- Python-side threading: Training code can do I/O while Rust computes

### 2. NumPy Array Interface

Feature vectors returned as `numpy.ndarray` (via the `numpy` crate). Zero-copy where possible.
- `reset()` returns `np.ndarray` shape `(n_features,)`, dtype `float64`
- `step()` returns `(np.ndarray, float, bool, bool, dict)` matching gymnasium

### 3. Gymnasium Compatibility

`observation_space` and `action_space` properties return actual `gymnasium.spaces` objects:
- `observation_space`: `gymnasium.spaces.Box(low=-inf, high=inf, shape=(n_features,), dtype=float64)`
- `action_space`: `gymnasium.spaces.Discrete(3)`

This enables direct use with `stable-baselines3` without wrapper classes.

### 4. Vectorized Environment

`PyVecTradingEnv` runs N independent simulations in parallel using rayon. Essential for V7.2 deep RL where training throughput depends on environment parallelism.

---

## Core Types

### PyTradingEnv (Single Environment)

```rust
use pyo3::prelude::*;
use numpy::{PyArray1, IntoPyArray};

#[pyclass]
pub struct PyTradingEnv {
    inner: gym::TradingEnv,
}

#[pymethods]
impl PyTradingEnv {
    #[new]
    #[pyo3(signature = (max_ticks=10000, seed=None, num_symbols=1))]
    fn new(max_ticks: u64, seed: Option<u64>, num_symbols: usize) -> PyResult<Self> {
        let config = build_config(max_ticks, seed, num_symbols);
        Ok(Self { inner: gym::TradingEnv::new(config) })
    }

    fn reset<'py>(&mut self, py: Python<'py>, seed: Option<u64>) -> Bound<'py, PyArray1<f64>> {
        let obs = py.allow_threads(|| self.inner.reset(seed));
        obs.into_pyarray(py)
    }

    fn step<'py>(
        &mut self,
        py: Python<'py>,
        action: i32,
    ) -> PyResult<(Bound<'py, PyArray1<f64>>, f64, bool, bool, PyObject)> {
        let action = match action {
            0 => gym::DiscreteAction::Sell,
            1 => gym::DiscreteAction::Hold,
            2 => gym::DiscreteAction::Buy,
            _ => return Err(pyo3::exceptions::PyValueError::new_err(
                "action must be 0 (sell), 1 (hold), or 2 (buy)"
            )),
        };

        let result = py.allow_threads(|| self.inner.step(action));

        let obs = result.observation.into_pyarray(py);
        let info = PyDict::new(py);
        info.set_item("tick", result.info.tick)?;
        info.set_item("equity", result.info.equity)?;
        info.set_item("realized_pnl", result.info.realized_pnl)?;

        Ok((obs, result.reward, result.terminated, result.truncated, info.into()))
    }

    #[getter]
    fn observation_space<'py>(&self, py: Python<'py>) -> PyResult<PyObject> {
        let gymnasium = py.import("gymnasium.spaces")?;
        let n = self.inner.observation_size() as i64;
        let kwargs = PyDict::new(py);
        kwargs.set_item("low", f64::NEG_INFINITY)?;
        kwargs.set_item("high", f64::INFINITY)?;
        kwargs.set_item("shape", (n,))?;
        kwargs.set_item("dtype", "float64")?;
        Ok(gymnasium.getattr("Box")?.call((), Some(&kwargs))?.into())
    }

    #[getter]
    fn action_space<'py>(&self, py: Python<'py>) -> PyResult<PyObject> {
        let gymnasium = py.import("gymnasium.spaces")?;
        Ok(gymnasium.getattr("Discrete")?.call1((3i64,))?.into())
    }

    /// Feature names for debugging/logging.
    fn feature_names(&self) -> Vec<String> {
        self.inner.feature_names().iter().map(|s| s.to_string()).collect()
    }
}
```

### PyVecTradingEnv (Parallel Environments)

```rust
use rayon::prelude::*;
use numpy::PyArray2;

#[pyclass]
pub struct PyVecTradingEnv {
    envs: Vec<gym::TradingEnv>,
    num_envs: usize,
}

#[pymethods]
impl PyVecTradingEnv {
    #[new]
    fn new(num_envs: usize, max_ticks: u64, base_seed: Option<u64>) -> PyResult<Self> {
        let envs = (0..num_envs)
            .map(|i| {
                let seed = base_seed.map(|s| s + i as u64);
                let config = build_config(max_ticks, seed, 1);
                gym::TradingEnv::new(config)
            })
            .collect();
        Ok(Self { envs, num_envs })
    }

    /// Reset all environments. Returns observations [num_envs, n_features].
    fn reset_all<'py>(
        &mut self,
        py: Python<'py>,
        seeds: Option<Vec<u64>>,
    ) -> Bound<'py, PyArray2<f64>> {
        let observations: Vec<Vec<f64>> = py.allow_threads(|| {
            self.envs.par_iter_mut().enumerate()
                .map(|(i, env)| {
                    let seed = seeds.as_ref().map(|s| s[i]);
                    env.reset(seed)
                })
                .collect()
        });
        // Stack into 2D array [num_envs, n_features]
        let n_features = observations[0].len();
        let flat: Vec<f64> = observations.into_iter().flatten().collect();
        PyArray2::from_vec2(py, &flat.chunks(n_features).map(|c| c.to_vec()).collect::<Vec<_>>())
            .expect("valid 2D array")
    }

    /// Step all environments in parallel. Returns (obs, rewards, terminateds, truncateds, infos).
    fn step_all<'py>(
        &mut self,
        py: Python<'py>,
        actions: Vec<i32>,
    ) -> PyResult<(
        Bound<'py, PyArray2<f64>>,
        Bound<'py, PyArray1<f64>>,
        Vec<bool>,
        Vec<bool>,
        Vec<PyObject>,
    )> {
        if actions.len() != self.num_envs {
            return Err(pyo3::exceptions::PyValueError::new_err(
                format!("expected {} actions, got {}", self.num_envs, actions.len())
            ));
        }

        let results: Vec<gym::StepResult> = py.allow_threads(|| {
            self.envs.par_iter_mut().zip(actions.par_iter())
                .map(|(env, &action)| {
                    let action = match action {
                        0 => gym::DiscreteAction::Sell,
                        1 => gym::DiscreteAction::Hold,
                        _ => gym::DiscreteAction::Buy,
                    };
                    env.step(action)
                })
                .collect()
        });

        let n_features = results[0].observation.len();
        let obs_flat: Vec<f64> = results.iter().flat_map(|r| r.observation.iter().copied()).collect();
        let rewards: Vec<f64> = results.iter().map(|r| r.reward).collect();
        let terminateds: Vec<bool> = results.iter().map(|r| r.terminated).collect();
        let truncateds: Vec<bool> = results.iter().map(|r| r.truncated).collect();

        let obs_2d = PyArray2::from_vec2(py, &obs_flat.chunks(n_features).map(|c| c.to_vec()).collect::<Vec<_>>())
            .expect("valid 2D array");
        let rewards_arr = rewards.into_pyarray(py);

        let infos: Vec<PyObject> = results.iter().map(|r| {
            let dict = PyDict::new(py);
            dict.set_item("tick", r.info.tick).unwrap();
            dict.set_item("equity", r.info.equity).unwrap();
            dict.into()
        }).collect();

        Ok((obs_2d, rewards_arr, terminateds, truncateds, infos))
    }

    /// Number of parallel environments.
    #[getter]
    fn num_envs(&self) -> usize { self.num_envs }
}
```

### Python Module Registration

```rust
#[pymodule]
fn quant_gym_rs(m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<PyTradingEnv>()?;
    m.add_class::<PyVecTradingEnv>()?;
    Ok(())
}
```

---

## Crate Structure

```
crates/gym-python/
├── Cargo.toml
│   [package]
│   name = "quant-gym-python"
│   edition = "2024"
│
│   [lib]
│   name = "quant_gym_rs"
│   crate-type = ["cdylib"]
│
│   [dependencies]
│   gym = { path = "../gym" }
│   pyo3 = { version = "0.23", features = ["extension-module"] }
│   numpy = "0.23"
│   rayon = "1.11"
│
├── pyproject.toml
│   [build-system]
│   requires = ["maturin>=1.0"]
│   build-backend = "maturin"
│
│   [project]
│   name = "quant-gym-rs"
│   requires-python = ">=3.9"
│
├── src/
│   ├── lib.rs          # #[pymodule] + module registration
│   ├── env.rs          # PyTradingEnv
│   ├── vec_env.rs      # PyVecTradingEnv
│   └── config.rs       # build_config() helper
```

**Workspace**: Add `"crates/gym-python"` to `Cargo.toml` workspace members.

---

## Python Usage Examples

### Basic Usage
```python
from quant_gym_rs import PyTradingEnv

env = PyTradingEnv(max_ticks=10000, seed=42)
obs = env.reset(seed=42)
print(f"Observation shape: {obs.shape}")  # (54,)
print(f"Feature names: {env.feature_names()[:5]}")

total_reward = 0
for step in range(10000):
    action = 1  # Hold
    obs, reward, terminated, truncated, info = env.step(action)
    total_reward += reward
    if terminated:
        print(f"Episode ended at step {step}, total reward: {total_reward:.2f}")
        break
```

### With scikit-learn (V6.2 Training)
```python
from quant_gym_rs import PyTradingEnv
import numpy as np

# Collect episodes for supervised learning
env = PyTradingEnv(max_ticks=5000, seed=0)
X, y = [], []

for episode in range(100):
    obs = env.reset(seed=episode)
    for _ in range(5000):
        action = np.random.choice([0, 1, 2])  # Random policy
        next_obs, reward, done, _, info = env.step(action)
        X.append(obs)
        y.append(1 if reward > 0 else (0 if reward == 0 else -1))
        obs = next_obs
        if done:
            break

X = np.array(X)
y = np.array(y)
```

### Vectorized (V7 Deep RL Preview)
```python
from quant_gym_rs import PyVecTradingEnv
import numpy as np

vec_env = PyVecTradingEnv(num_envs=8, max_ticks=10000, base_seed=42)
obs = vec_env.reset_all()  # shape: (8, 54)

for _ in range(10000):
    actions = np.random.randint(0, 3, size=8).tolist()
    obs, rewards, dones, truncs, infos = vec_env.step_all(actions)
    # Auto-reset terminated envs
    for i, done in enumerate(dones):
        if done:
            # Individual reset handled by env internally (or manually)
            pass
```

### Build & Install
```bash
cd crates/gym-python
pip install maturin
maturin develop --release  # Install into current venv

# Verify
python -c "from quant_gym_rs import PyTradingEnv; print('OK')"
```

---

## Verification

1. `cargo test -p quant-gym-python` — Rust-side unit tests (config conversion, action validation)
2. `maturin develop --release` — builds successfully
3. `python -c "from quant_gym_rs import PyTradingEnv; env = PyTradingEnv(); obs = env.reset(); print(obs.shape)"` — imports and runs
4. `gymnasium.utils.env_checker.check_env(env)` — passes gymnasium compatibility check
5. Performance test: measure steps/second for single and vectorized envs
6. Reproducibility test: two runs with same seed produce identical observation sequences
