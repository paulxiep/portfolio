# V5.2: Simulation Struct Decomposition

**Goal**: Decompose the 1,500-line `Simulation` struct into modular subsystems with trait-based interfaces, following the "Declarative, Modular, SoC" philosophy.

---

## Problem Statement

The `Simulation` struct in `runner.rs` handles too many concerns:
- Agent management (T1/T2/T3 tiers)
- Order processing & batch auctions
- Market data (candles, trades, indicators)
- News & fundamentals
- Risk tracking & position validation
- Hook system
- Tick orchestration

This violates SoC and makes the code hard to test, extend, and maintain.

---

## Design Principles

- **Separation of Concerns**: Each subsystem owns one responsibility
- **Declarative Interfaces**: Traits define "what", implementations define "how"
- **Modular Composition**: Subsystems interact via trait bounds, not concrete types
- **Testable**: Traits enable mocking without needing full simulation

---

## Architecture

```
                    ┌─────────────────────────────────────┐
                    │            Simulation               │
                    │  (Thin orchestrator, owns Market)   │
                    └───────────────┬─────────────────────┘
                                    │
        ┌───────────┬───────────┬───┴───┬───────────┬───────────┐
        ▼           ▼           ▼       ▼           ▼           ▼
   ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐
   │ Market  │ │ Agent   │ │ Auction │ │  Risk   │ │  News   │ │  Hook   │
   │  Data   │ │Orchestr.│ │ Engine  │ │ Manager │ │ Engine  │ │ Runner  │
   └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘
        │           │           │           │           │           │
   implements  implements  implements  implements  implements  (already
        │           │           │           │           │       extracted)
        ▼           ▼           ▼           ▼           ▼
   MarketData  AgentExec   Auctioneer  RiskTracker  Fundament.
   Provider    Coordinator              + PositionTracker  Provider
```

---

## Part 1: Trait Definitions

### MarketDataProvider

Provides access to historical market data (candles, trades, indicators).

```rust
pub trait MarketDataProvider {
    fn candles_for(&self, symbol: &Symbol) -> &[Candle];
    fn all_candles(&self) -> &HashMap<Symbol, VecDeque<Candle>>;
    fn recent_trades_for(&self, symbol: &Symbol) -> &[Trade];
    fn all_recent_trades(&self) -> &HashMap<Symbol, Vec<Trade>>;
    fn build_indicator_snapshot(&mut self) -> IndicatorSnapshot;
    fn build_indicators_for_hook(&self) -> HashMap<Symbol, HashMap<String, f64>>;
}
```

**Why a trait?**
- Agents could use a mock `MarketDataProvider` in unit tests
- Could implement `FileBackedMarketData` for historical replay
- Decouples agents from `Simulation` concrete type

### AgentExecutionCoordinator

Coordinates agent execution across tiers.

```rust
pub trait AgentExecutionCoordinator {
    fn add_agent(&mut self, agent: Box<dyn Agent>, initial_tick: Tick);
    fn agent_count(&self) -> usize;
    fn compute_agents_to_call(
        &mut self,
        tick: Tick,
        prices: &[(Symbol, Price)],
        news_symbols: &[Symbol],
    ) -> (Vec<usize>, HashMap<AgentId, SmallVec<[WakeCondition; 2]>>);
    fn collect_actions(
        &self,
        indices: &[usize],
        ctx: &StrategyContext<'_>,
        force_sequential: bool,
    ) -> Vec<AgentActionWithState>;
    fn build_position_cache(
        &self,
        force_sequential: bool,
    ) -> HashMap<AgentId, HashMap<Symbol, i64>>;
    fn notify_fills(
        &mut self,
        fills: &[(AgentId, Trade, i64)],
        force_sequential: bool,
    );
    fn restore_wake_conditions(
        &mut self,
        triggered: &HashMap<AgentId, SmallVec<[WakeCondition; 2]>>,
        force_sequential: bool,
    );
    fn agent_summaries(
        &self,
        prices: &HashMap<Symbol, Price>,
        force_sequential: bool,
    ) -> Vec<AgentSummary>;
}

pub struct AgentSummary {
    pub name: String,
    pub positions: HashMap<Symbol, i64>,
    pub cash: Cash,
    pub total_pnl: Cash,
}
```

**Why a trait?**
- Test strategies with mock agent coordinators
- Could implement `ReplayAgentCoordinator` that replays recorded actions
- Separates agent management complexity from tick orchestration

### Auctioneer

Handles order collection and batch auction execution.

```rust
pub trait Auctioneer {
    fn collect_orders(
        &mut self,
        actions: Vec<AgentActionWithState>,
        market: &mut Market,
        position_tracker: &dyn PositionTracker,
        enforce_limits: bool,
        verbose: bool,
        stats: &mut SimulationStats,
    ) -> HashMap<Symbol, Vec<Order>>;
    fn build_reference_prices(
        &self,
        orders: &HashMap<Symbol, Vec<Order>>,
        market: &Market,
        symbol_configs: &[SymbolConfig],
        force_sequential: bool,
    ) -> HashMap<Symbol, Price>;
    fn run_auctions(
        &mut self,
        orders: HashMap<Symbol, Vec<Order>>,
        reference_prices: &HashMap<Symbol, Price>,
        timestamp: Timestamp,
        tick: Tick,
        force_sequential: bool,
    ) -> HashMap<Symbol, BatchAuctionResult>;
}
```

**Why a trait?**
- Could swap auction algorithms (continuous, call auction, pro-rata)
- Test order validation logic with mock position tracker
- Enables A/B testing of auction mechanisms

### PositionTracker

Tracks position limits and borrow state.

```rust
pub trait PositionTracker {
    fn borrow_ledger(&self) -> &BorrowLedger;
    fn total_shares_held_for(&self, symbol: &Symbol) -> Quantity;
    fn all_total_shares(&self) -> &HashMap<Symbol, Quantity>;
    fn validate_order(
        &self,
        order: &Order,
        agent_position: i64,
        agent_cash: Cash,
        is_market_maker: bool,
        enforce_limits: bool,
    ) -> Result<(), RiskViolation>;
}
```

### RiskTracker

Tracks agent risk metrics over time.

```rust
pub trait RiskTracker {
    fn record_equity(&mut self, agent_id: AgentId, equity: f64);
    fn compute_all_metrics(&self) -> HashMap<AgentId, AgentRiskSnapshot>;
    fn compute_metrics(&self, agent_id: AgentId) -> AgentRiskSnapshot;
}
```

### FundamentalsProvider

Provides news events and fundamental data.

```rust
pub trait FundamentalsProvider {
    fn process_tick(
        &mut self,
        tick: Tick,
        drift_config: &FairValueDriftConfig,
        verbose: bool,
    );
    fn active_events(&self) -> &[NewsEvent];
    fn fundamentals(&self) -> &SymbolFundamentals;
    fn fair_value(&self, symbol: &Symbol) -> Option<Price>;
    fn get_news_snapshots(&self, tick: Tick) -> Vec<NewsEventSnapshot>;
}
```

**Why a trait?**
- Test agents with deterministic news (seeded generator)
- Could implement `ScriptedNewsProvider` for specific scenarios
- Decouples price dynamics from simulation core

### Tier3OrderGenerator

Generates background pool orders.

```rust
pub trait Tier3OrderGenerator {
    fn generate_orders(&mut self, ctx: &PoolContext) -> Vec<Order>;
    fn update_accounting(&mut self, trades: &[Trade]);
    fn pool_size(&self) -> usize;
}
```

---

## Part 2: Struct Implementations

### MarketDataManager

```rust
pub struct MarketDataManager {
    candles: HashMap<Symbol, VecDeque<Candle>>,
    current_candles: HashMap<Symbol, CandleBuilder>,
    recent_trades: HashMap<Symbol, Vec<Trade>>,
    indicator_engine: IndicatorEngine,
    indicator_cache: IndicatorCache,
    candle_interval: u64,
    max_candles: usize,
    max_recent_trades: usize,
}

impl MarketDataManager {
    pub fn new(symbols: &[Symbol], candle_interval: u64, max_candles: usize, max_recent_trades: usize) -> Self;
    pub fn update_candles(&mut self, trades: &[Trade], tick: Tick, timestamp: Timestamp, market: &Market);
    pub fn update_recent_trades(&mut self, trades: &[Trade]);
    pub fn indicator_engine_mut(&mut self) -> &mut IndicatorEngine;
}

impl MarketDataProvider for MarketDataManager { ... }
```

### AgentOrchestrator

```rust
pub struct AgentOrchestrator {
    agents: Vec<Mutex<Box<dyn Agent>>>,
    t1_indices: Vec<usize>,
    t2_indices: Vec<usize>,
    agent_id_to_index: HashMap<AgentId, usize>,
    wake_index: WakeConditionIndex,
    background_pool: Option<BackgroundAgentPool>,
}

impl AgentOrchestrator {
    pub fn new() -> Self;
    pub fn set_background_pool(&mut self, pool: BackgroundAgentPool);
    pub fn background_pool(&self) -> Option<&BackgroundAgentPool>;
    pub fn wake_index_stats(&self) -> IndexStats;
    pub fn cleanup_expired_conditions(&mut self, tick: Tick);
}

impl AgentExecutionCoordinator for AgentOrchestrator { ... }
impl Tier3OrderGenerator for AgentOrchestrator { ... }
```

### AuctionEngine

```rust
pub struct AuctionEngine {
    position_validator: PositionValidator,
    next_order_id: u64,
}

impl AuctionEngine {
    pub fn new(position_config: SymbolConfig, short_config: ShortSellingConfig) -> Self;
}

impl Auctioneer for AuctionEngine { ... }
```

### RiskManager

```rust
pub struct RiskManager {
    borrow_ledger: BorrowLedger,
    total_shares_held: HashMap<Symbol, Quantity>,
    risk_tracker: AgentRiskTracker,
}

impl RiskManager {
    pub fn new(symbols: &[Symbol], borrow_pool_sizes: &HashMap<Symbol, Quantity>) -> Self;
    pub fn process_trade(&mut self, trade: &Trade, seller_pos: i64, buyer_pos: i64, tick: Tick);
    pub fn update_equities(&mut self, equities: &[(AgentId, f64)]);
}

impl PositionTracker for RiskManager { ... }
impl RiskTracker for RiskManager { ... }
```

### NewsEngine

```rust
pub struct NewsEngine {
    news_generator: NewsGenerator,
    active_events: Vec<NewsEvent>,
    fundamentals: SymbolFundamentals,
    drift_rng: StdRng,
}

impl NewsEngine {
    pub fn new(config: NewsConfig, symbols: Vec<Symbol>, sector_model: SectorModel, seed: u64) -> Self;
}

impl FundamentalsProvider for NewsEngine { ... }
```

---

## Part 3: Simplified Simulation

```rust
pub struct Simulation {
    // Core market (owned by Simulation, shared via reference)
    market: Market,

    // Subsystems (owned, implement traits)
    market_data: MarketDataManager,
    agents: AgentOrchestrator,
    auction: AuctionEngine,
    risk: RiskManager,
    news: NewsEngine,
    hooks: HookRunner,

    // Timing
    tick: Tick,
    timestamp: Timestamp,
    stats: SimulationStats,

    // Config
    config: SimulationConfig,
    symbol_sectors: HashMap<Symbol, Sector>,
}

impl Simulation {
    pub fn new(config: SimulationConfig) -> Self { ... }  // ~50 lines
    pub fn step(&mut self) -> Vec<Trade> { ... }         // ~100 lines, calls subsystems
}
```

---

## Part 4: API Simplification

### Methods to Remove

**Primary-Symbol Shortcuts (Redundant)**

| Remove | Replace With |
|--------|--------------|
| `book()` | `get_book(&config.symbol())` |
| `recent_trades()` | `recent_trades_for(symbol)` |
| `candles()` | `candles_for(symbol)` |
| `total_shares_held()` | `total_shares_held_for(symbol)` |

**Internal Subsystem Accessors (Encapsulation Violation)**

| Remove | Rationale |
|--------|-----------|
| `borrow_ledger()` | Internal to RiskManager |
| `position_validator()` | Internal to AuctionEngine |
| `wake_index_stats()` | Debug-only, move to stats if needed |
| `background_pool()` | Pool size in stats |
| `background_pool_mut()` | Not needed after setup |

### Final Public API

```rust
impl Simulation {
    // Construction
    pub fn new(config: SimulationConfig) -> Self;

    // Execution
    pub fn step(&mut self) -> Vec<Trade>;
    pub fn run(&mut self, ticks: u64) -> Vec<Trade>;

    // Agent management
    pub fn add_agent(&mut self, agent: Box<dyn Agent>);
    pub fn set_background_pool(&mut self, pool: BackgroundAgentPool);
    pub fn agent_count(&self) -> usize;

    // Hook management
    pub fn add_hook(&mut self, hook: Arc<dyn SimulationHook>);
    pub fn hook_count(&self) -> usize;

    // Timing & stats
    pub fn tick(&self) -> Tick;
    pub fn timestamp(&self) -> Timestamp;
    pub fn stats(&self) -> &SimulationStats;
    pub fn config(&self) -> &SimulationConfig;

    // Market access
    pub fn market(&self) -> &Market;
    pub fn get_book(&self, symbol: &Symbol) -> Option<&OrderBook>;

    // Market data (delegates to MarketDataManager)
    pub fn candles_for(&self, symbol: &Symbol) -> &[Candle];
    pub fn all_candles(&self) -> &HashMap<Symbol, VecDeque<Candle>>;
    pub fn recent_trades_for(&self, symbol: &Symbol) -> &[Trade];
    pub fn all_recent_trades(&self) -> &HashMap<Symbol, Vec<Trade>>;
    pub fn indicator_engine(&self) -> &IndicatorEngine;
    pub fn indicator_engine_mut(&mut self) -> &mut IndicatorEngine;

    // Agent data
    pub fn agent_summaries(&self) -> Vec<AgentSummary>;

    // Risk data
    pub fn agent_risk_metrics(&self) -> HashMap<AgentId, AgentRiskSnapshot>;
    pub fn agent_risk(&self, agent_id: AgentId) -> AgentRiskSnapshot;
    pub fn total_shares_held_for(&self, symbol: &Symbol) -> Quantity;

    // News/fundamentals
    pub fn active_events(&self) -> &[NewsEvent];
    pub fn fundamentals(&self) -> &SymbolFundamentals;
    pub fn fair_value(&self, symbol: &Symbol) -> Option<Price>;
}
```

---

## File Structure

```
crates/simulation/src/
├── lib.rs                    # Module declarations and re-exports
├── config.rs                 # SimulationConfig (unchanged)
├── runner.rs                 # Simulation struct (~300 lines)
├── hooks.rs                  # SimulationHook trait (unchanged)
├── metrics.rs                # MetricsHook (unchanged)
├── parallel.rs               # Parallel utilities (unchanged)
│
├── traits/
│   ├── mod.rs                # Trait re-exports
│   ├── market_data.rs        # MarketDataProvider trait
│   ├── agents.rs             # AgentExecutionCoordinator, Tier3OrderGenerator
│   ├── auction.rs            # Auctioneer trait
│   ├── risk.rs               # PositionTracker, RiskTracker traits
│   └── fundamentals.rs       # FundamentalsProvider trait
│
├── subsystems/
│   ├── mod.rs                # Subsystem re-exports
│   ├── market_data.rs        # MarketDataManager (~200 lines)
│   ├── agents.rs             # AgentOrchestrator (~350 lines)
│   ├── auction.rs            # AuctionEngine (~200 lines)
│   ├── risk.rs               # RiskManager (~150 lines)
│   └── news.rs               # NewsEngine (~150 lines)
```

---

## Migration Steps

1. **Create `traits/` module** with all trait definitions
2. **Create `subsystems/` module** with empty struct skeletons
3. **Move fields** from `Simulation` to appropriate subsystem
4. **Implement traits** for each subsystem
5. **Update `Simulation::new()`** to initialize subsystems
6. **Refactor `step()`** to call trait methods on subsystems
7. **Remove deprecated API methods** from `Simulation`
8. **Update consumers** (`main.rs`, tests) to use new APIs
9. **Update tests** to use new structure

---

## Consumer Updates Required

### main.rs

1. Replace `sim.book()` → `sim.get_book(&sim.config().symbol().to_string())`
2. Replace `sim.recent_trades()` → `sim.recent_trades_for(&symbol)`
3. Replace `sim.candles()` → `sim.candles_for(&symbol)`

### Tests

1. Update any tests using removed methods
2. If testing borrow logic, use `RiskManager` directly

---

## Verification Plan

### Unit Tests

Each subsystem should have isolated tests:

```rust
#[cfg(test)]
mod market_data_tests {
    fn test_candle_finalization() { ... }
    fn test_indicator_computation() { ... }
}

#[cfg(test)]
mod auction_tests {
    fn test_order_validation() { ... }
    fn test_batch_auction_clearing() { ... }
}
```

### Integration Tests

1. **Headless mode:** `cargo run -- headless --ticks 1000`
2. **TUI mode:** Manual verification of dashboard data
3. **Server mode:** REST + WebSocket endpoint verification

### Benchmark

Compare tick throughput before/after to ensure no regression.

---

## Timeline

~3-4 days total:
- Day 1: Create traits module, define all interfaces
- Day 2: Create subsystems, move fields and methods
- Day 3: Refactor `Simulation`, update `step()`
- Day 4: API cleanup, consumer updates, testing
